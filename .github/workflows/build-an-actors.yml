name: Build AN actors (codes + rôles)

on:
  push:
    paths:
      - "json/acteur/**"
      - "json/organe/**"
      - ".github/workflows/build-an-actors.yml"
  workflow_dispatch:

permissions:
  contents: write

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Vérifier la présence des dossiers
        run: |
          set -e
          if [ ! -d json/acteur ] || [ ! -d json/organe ]; then
            echo "::error::Dossiers json/acteur ou json/organe introuvables dans le dépôt."
            exit 1
          fi
          echo "OK: json/acteur et json/organe trouvés."

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Générer data/an_actors.json
        run: |
          node - <<'NODE'
          const fs = require('fs');
          const path = require('path');

          const ACTEUR_DIR = 'json/acteur';
          const ORGANE_DIR = 'json/organe';
          const OUT_DIR    = 'data';
          const OUT_FILE   = path.join(OUT_DIR, 'an_actors.json');

          function listJsonFiles(dir){
            return fs.readdirSync(dir)
              .filter(f => f.toLowerCase().endsWith('.json'))
              .map(f => path.join(dir, f));
          }

          function readJson(p){
            try { return JSON.parse(fs.readFileSync(p, 'utf8')); }
            catch(e){ return null; }
          }

          // --- 1) Index des organes
          const organes = {};
          for (const f of listJsonFiles(ORGANE_DIR)) {
            const base = path.basename(f, '.json');   // ex: PO59047
            const j = readJson(f);
            if (!j) continue;
            // Champs possibles selon versions AMO : codeType, type, libelle, libelleAbrege, nom
            const codeType = j.codeType || j.type || (j.categorie && j.categorie.code) || null;
            const libelle  = j.libelle || j.libelleAbrege || j.nom || base;
            organes[base] = { code: base, codeType, libelle };
          }

          // --- 2) Balise utilitaires
          function pickName(j){
            // Plusieurs schémas possibles; on tente du plus précis au plus simple
            const ec = j.etatCivil || {};
            const ident = ec.ident || ec.identite || {};
            const nom = ident.nomUsuel || ident.nom || j.nom || '';
            const prenom = ident.prenom || j.prenom || '';
            const tri = j.tri || ''; // "NOM PRÉNOM"
            let full = (nom && prenom) ? `${prenom} ${nom}`.trim() : (nom || tri || '—').trim();
            // Capitalisation légère si tout est upper
            if (/^[A-ZÉÈÀÙÂÊÎÔÛÄËÏÖÜÇ -]+$/.test(full) && full.includes(' ')) {
              full = full.split(' ').map(w => w.charAt(0) + w.slice(1).toLowerCase()).join(' ');
            }
            return full;
          }

          function detectRolesFromMandats(mandats){
            const roles = new Set();
            for (const m of Array.isArray(mandats) ? mandats : []) {
              const orgRef = m.organeRef || m.organe || m.organeParticipant || m.organisme || null;
              const typeOrg = m.typeOrgane || m.type || null;
              const og = organes[String(orgRef)] || null;
              const t = (typeOrg || (og && og.codeType) || '').toUpperCase();

              // Heuristiques robustes :
              if (t.includes('ASSEMBLEE') || t === 'AN') roles.add('depute');
              if (t.includes('SENAT') || t === 'SN')    roles.add('senateur');
              if (t.includes('GOUVERNEMENT') || t === 'GOUVERNEMENT') roles.add('ministre');
            }
            return Array.from(roles);
          }

          function findMainGroup(mandats){
            // On tente de repérer un mandat lié à un groupe parlementaire (GP)
            for (const m of Array.isArray(mandats) ? mandats : []) {
              const orgRef = String(m.organeRef || '');
              const og = organes[orgRef];
              if (!og) continue;
              const t = (og.codeType || '').toUpperCase();
              if (t.includes('GP') || og.libelle?.toLowerCase().includes('groupe')) {
                return { code: og.code, libelle: og.libelle };
              }
            }
            return null;
          }

          // --- 3) Parcours des acteurs (PAxxxx.json)
          const out = [];
          let seen = 0;

          for (const f of listJsonFiles(ACTEUR_DIR)) {
            const code = path.basename(f, '.json'); // "PAxxxx"
            const j = readJson(f);
            if (!j) continue;

            // Structure AMO : mandats au niveau racine ou sous-clés
            const mandats = j.mandats || j.mandat || j.mandatsSanction || j.Mandats || [];

            const item = {
              code,
              nom: pickName(j),
              roles: detectRolesFromMandats(mandats)
            };

            const grp = findMainGroup(mandats);
            if (grp) item.groupe = grp;

            out.push(item);
            seen++;
          }

          // --- 4) Sortie
          fs.mkdirSync(OUT_DIR, { recursive: true });
          fs.writeFileSync(OUT_FILE, JSON.stringify(out, null, 2), 'utf8');

          console.log(`Écrit ${OUT_FILE} avec ${seen} entrées (acteurs).`);
          NODE

      - name: Commit & push si modifications
        run: |
          set -e
          if [ -n "$(git status --porcelain data/an_actors.json)" ]; then
            git config user.name  "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            git add data/an_actors.json
            git commit -m "build(an): update data/an_actors.json"
            git push
          else
            echo "Aucun changement à committer."
          fi
